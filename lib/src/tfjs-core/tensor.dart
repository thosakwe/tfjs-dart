@JS() library tfjs.node_modules._tensorflow.tfjs_core.dist.tensor ; import "package:js/js.dart" ;
 import "types.dart" show ShapeMap ;
@anonymous @JS() abstract class TensorData { external object get dataId; external set dataId(object v); external List<DataTypeMap> get values; external set values(List<DataTypeMap> v); external factory TensorData({ object dataId, List<DataTypeMap> values}); }

 @JS() class TensorBuffer <R extends num/*enum Rank*/ > { // @Ignore
 TensorBuffer .fakeConstructor$() ;
 external keyof get dtype; external set dtype(keyof v); external num get size; external set size(num v); external List<ShapeMap> get shape; external set shape(List<ShapeMap> v); external List<DataTypeMap> get values; external set values(List<DataTypeMap> v); external get strides; external set strides(v); external factory TensorBuffer([List<ShapeMap> shape]); external keyof get dtype; external set dtype(keyof v); external List<DataTypeMap> get values; external set values(List<DataTypeMap> v); external void JS$set(num value, [num locs1, num locs2, num locs3, num locs4, num locs5]); external num JS$get([num locs1, num locs2, num locs3, num locs4, num locs5]); external num locToIndex(List<num> locs); external List<num> indexToLoc(num index); external num get rank; external set rank(num v); external Tensor<R> toTensor(); }

 /*export declare type DataId = object;*/ 
 @JS() class Tensor <R extends Rank, Rank > { // @Ignore
 Tensor .fakeConstructor$() ;
 external static get nextId; external static set nextId(v); external num get id; external set id(num v); external object get dataId; external set dataId(object v); external List<ShapeMap> get shape; external set shape(List<ShapeMap> v); external num get size; external set size(num v); external keyof get dtype; external set dtype(keyof v); external R get rankType; external set rankType(R v); external List<num> get strides; external set strides(List<num> v); external factory Tensor([List<ShapeMap> shape]); external keyof get dtype; external set dtype(keyof v); external List<DataTypeMap> get values; external set values(List<DataTypeMap> v); external object get dataId; external set dataId(object v); external static make /*<T extends Tensor<R>, D extends keyof>*/(); external get String /*"float32"*/; external set String /*"float32"*/(v); external get R; external set R(v); external get Rank; external set Rank(v); external get ShapeMap; external set ShapeMap(v); external TensorData get data; external set data(TensorData v); external D get dtype; external set dtype(D v); external get T; external set T(v); external Tensor<Rank.R1> flatten(); external Tensor<Rank.R0> asScalar(); external Tensor<Rank.R1> as1D(); external Tensor<Rank.R2> as2D(num rows, num columns); external Tensor<Rank.R3> as3D(num rows, num columns, num depth); external Tensor<Rank.R4> as4D(num rows, num columns, num depth, num depth2); external dynamic/*=T*/ asType /*<T extends Tensor>*/( /*T this*/ keyof dtype); external num get rank; external set rank(num v); external num JS$get([num locs1, num locs2, num locs3, num locs4, num locs5]); external TensorBuffer<R> buffer(); external Promise<List<DataTypeMap>> data(); external List<DataTypeMap> dataSync(); external void dispose(); external get isDisposed; external set isDisposed(v); external throwIfDisposed(); external dynamic/*=T*/ toFloat /*<T extends Tensor>*/( /*T this*/); external Tensor toInt(); external Tensor toBool(); external void print([bool verbose]); external reshape /*<R2 extends Rank>*/([List<ShapeMap> newShape]); external Tensor /*<R2>*/(); external dynamic/*=T*/ reshapeAs /*<T extends Tensor>*/(dynamic/*=T*/ x); external Tensor<dynamic/*=R2*/> expandDims /*<R2 extends Rank>*/([num axis]); external dynamic/*=T*/ squeeze /*<T extends Tensor>*/([List<num> axis]); external dynamic/*=T*/ clone /*<T extends Tensor>*/( /*T this*/); external String toString([bool verbose]); external dynamic/*=T*/ tile /*<T extends Tensor>*/( /*T this*/ List<num> reps); external dynamic/*=T*/ gather /*<T extends Tensor>*/( /*T this*/ Tensor<Rank.R1> indices, [num axis]); external Tensor<Rank.R2> matMul(Tensor<Rank.R2> b, [bool transposeA, bool transposeB]); external Tensor norm([dynamic/*num|'euclidean'|'fro'*/ ord, dynamic/*num|List<num>*/ axis, bool keepDims]); external dynamic/*=T*/ slice /*<T extends Tensor<R>>*/( /*T this*/ dynamic/*num|List<num>*/ begin, [dynamic/*num|List<num>*/ size]); external dynamic/*=T*/ reverse /*<T extends Tensor>*/( /*T this*/ [dynamic/*num|List<num>*/ axis]); external dynamic/*=T*/ concat /*<T extends Tensor>*/( /*T this*/ dynamic/*=T*/ x, [num axis]); external Tensor stack(Tensor x, [num axis]); external dynamic/*=T*/ pad /*<T extends Tensor>*/( /*T this*/ List<List<num>/*Tuple of <num,num>*/> paddings, [num constantValue]); external Tensor<R> batchNormalization(Tensor/*Tensor<R>|Tensor<Rank.R1>*/ mean, Tensor/*Tensor<R>|Tensor<Rank.R1>*/ variance, [num varianceEpsilon, Tensor/*Tensor<R>|Tensor<Rank.R1>*/ scale, Tensor/*Tensor<R>|Tensor<Rank.R1>*/ offset]); external dynamic/*=T*/ logSumExp /*<T extends Tensor>*/([dynamic/*num|List<num>*/ axis, bool keepDims]); external dynamic/*=T*/ sum /*<T extends Tensor>*/([dynamic/*num|List<num>*/ axis, bool keepDims]); external dynamic/*=T*/ mean /*<T extends Tensor>*/([dynamic/*num|List<num>*/ axis, bool keepDims]); external dynamic/*=T*/ min /*<T extends Tensor>*/([dynamic/*num|List<num>*/ axis, bool keepDims]); external dynamic/*=T*/ max /*<T extends Tensor>*/([dynamic/*num|List<num>*/ axis, bool keepDims]); external dynamic/*=T*/ argMin /*<T extends Tensor>*/([num axis]); external dynamic/*=T*/ argMax /*<T extends Tensor>*/([num axis]); external dynamic/*=T*/ cast /*<T extends Tensor>*/(keyof dtype); external dynamic/*=T*/ add /*<T extends Tensor>*/(Tensor x); external dynamic/*=T*/ addStrict /*<T extends Tensor>*/( /*T this*/ dynamic/*=T*/ x); external dynamic/*=T*/ sub /*<T extends Tensor>*/(Tensor x); external dynamic/*=T*/ subStrict /*<T extends Tensor>*/( /*T this*/ dynamic/*=T*/ x); external dynamic/*=T*/ pow /*<T extends Tensor>*/( /*T this*/ Tensor exp); external Tensor<R> powStrict(Tensor exp); external dynamic/*=T*/ mul /*<T extends Tensor>*/(Tensor x); external dynamic/*=T*/ mulStrict /*<T extends Tensor>*/( /*T this*/ dynamic/*=T*/ x); external dynamic/*=T*/ div /*<T extends Tensor>*/(Tensor x); external dynamic/*=T*/ divStrict /*<T extends Tensor>*/( /*T this*/ dynamic/*=T*/ x); external dynamic/*=T*/ minimum /*<T extends Tensor>*/(Tensor x); external dynamic/*=T*/ minimumStrict /*<T extends Tensor>*/( /*T this*/ dynamic/*=T*/ x); external dynamic/*=T*/ maximum /*<T extends Tensor>*/(Tensor x); external dynamic/*=T*/ maximumStrict /*<T extends Tensor>*/( /*T this*/ dynamic/*=T*/ x); external dynamic/*=T*/ mod /*<T extends Tensor>*/(Tensor x); external dynamic/*=T*/ modStrict /*<T extends Tensor>*/( /*T this*/ dynamic/*=T*/ x); external dynamic/*=T*/ squaredDifference /*<T extends Tensor>*/(Tensor x); external dynamic/*=T*/ squaredDifferenceStrict /*<T extends Tensor>*/( /*T this*/ dynamic/*=T*/ x); external dynamic/*=T*/ transpose /*<T extends Tensor>*/( /*T this*/ [List<num> perm]); external dynamic/*=T*/ notEqual /*<T extends Tensor>*/(Tensor x); external dynamic/*=T*/ notEqualStrict /*<T extends Tensor>*/( /*T this*/ dynamic/*=T*/ x); external dynamic/*=T*/ less /*<T extends Tensor>*/(Tensor x); external dynamic/*=T*/ lessStrict /*<T extends Tensor>*/( /*T this*/ dynamic/*=T*/ x); external dynamic/*=T*/ equal /*<T extends Tensor>*/(Tensor x); external dynamic/*=T*/ equalStrict /*<T extends Tensor>*/( /*T this*/ dynamic/*=T*/ x); external dynamic/*=T*/ lessEqual /*<T extends Tensor>*/(Tensor x); external dynamic/*=T*/ lessEqualStrict /*<T extends Tensor>*/( /*T this*/ dynamic/*=T*/ x); external dynamic/*=T*/ greater /*<T extends Tensor>*/(Tensor x); external dynamic/*=T*/ greaterStrict /*<T extends Tensor>*/( /*T this*/ dynamic/*=T*/ x); external dynamic/*=T*/ greaterEqual /*<T extends Tensor>*/(Tensor x); external dynamic/*=T*/ greaterEqualStrict /*<T extends Tensor>*/( /*T this*/ dynamic/*=T*/ x); external Tensor logicalAnd(Tensor x); external Tensor logicalOr(Tensor x); external dynamic/*=T*/ logicalNot /*<T extends Tensor>*/( /*T this*/); external Tensor logicalXor(Tensor x); external Tensor where(Tensor condition, Tensor x); external dynamic/*=T*/ neg /*<T extends Tensor>*/( /*T this*/); external dynamic/*=T*/ ceil /*<T extends Tensor>*/( /*T this*/); external dynamic/*=T*/ floor /*<T extends Tensor>*/( /*T this*/); external dynamic/*=T*/ sign /*<T extends Tensor>*/( /*T this*/); external dynamic/*=T*/ exp /*<T extends Tensor>*/( /*T this*/); external dynamic/*=T*/ expm1 /*<T extends Tensor>*/( /*T this*/); external dynamic/*=T*/ log /*<T extends Tensor>*/( /*T this*/); external dynamic/*=T*/ log1p /*<T extends Tensor>*/( /*T this*/); external dynamic/*=T*/ sqrt /*<T extends Tensor>*/( /*T this*/); external dynamic/*=T*/ rsqrt /*<T extends Tensor>*/( /*T this*/); external dynamic/*=T*/ square /*<T extends Tensor>*/( /*T this*/); external dynamic/*=T*/ reciprocal /*<T extends Tensor>*/( /*T this*/); external dynamic/*=T*/ abs /*<T extends Tensor>*/( /*T this*/); external Tensor<R> clipByValue(num min, num max); external dynamic/*=T*/ relu /*<T extends Tensor>*/( /*T this*/); external dynamic/*=T*/ elu /*<T extends Tensor>*/( /*T this*/); external dynamic/*=T*/ selu /*<T extends Tensor>*/( /*T this*/); external Tensor<R> leakyRelu([num alpha]); external Tensor<R> prelu(Tensor<R> alpha); external dynamic/*=T*/ sigmoid /*<T extends Tensor>*/( /*T this*/); external dynamic/*=T*/ logSigmoid /*<T extends Tensor>*/( /*T this*/); external dynamic/*=T*/ softplus /*<T extends Tensor>*/( /*T this*/); external dynamic/*=T*/ sin /*<T extends Tensor>*/( /*T this*/); external dynamic/*=T*/ cos /*<T extends Tensor>*/( /*T this*/); external dynamic/*=T*/ tan /*<T extends Tensor>*/( /*T this*/); external dynamic/*=T*/ asin /*<T extends Tensor>*/( /*T this*/); external dynamic/*=T*/ acos /*<T extends Tensor>*/( /*T this*/); external dynamic/*=T*/ atan /*<T extends Tensor>*/( /*T this*/); external dynamic/*=T*/ sinh /*<T extends Tensor>*/( /*T this*/); external dynamic/*=T*/ cosh /*<T extends Tensor>*/( /*T this*/); external dynamic/*=T*/ tanh /*<T extends Tensor>*/( /*T this*/); external dynamic/*=T*/ asinh /*<T extends Tensor>*/( /*T this*/); external dynamic/*=T*/ acosh /*<T extends Tensor>*/( /*T this*/); external dynamic/*=T*/ atanh /*<T extends Tensor>*/( /*T this*/); external dynamic/*=T*/ erf /*<T extends Tensor>*/( /*T this*/); external dynamic/*=T*/ step /*<T extends Tensor>*/( /*T this*/ [num alpha]); external dynamic/*=T*/ softmax /*<T extends Tensor>*/( /*T this*/ [num dim]); external dynamic/*=T*/ resizeBilinear /*<T extends Tensor<Rank.R3>|Tensor<Rank.R4>>*/( /*T this*/ List<num>/*Tuple of <num,num>*/ newShape2D, [bool alignCorners]); external dynamic/*=T*/ resizeNearestNeighbor /*<T extends Tensor<Rank.R3>|Tensor<Rank.R4>>*/( /*T this*/ List<num>/*Tuple of <num,num>*/ newShape2D, [bool alignCorners]); external dynamic/*=T*/ conv1d /*<T extends Tensor<Rank.R2>|Tensor<Rank.R3>>*/( /*T this*/ Tensor<Rank.R3> filter, num stride, dynamic/*'valid'|'same'|num*/ pad, [String/*'NWC'|'NCW'*/ dataFormat, num dilation, String/*'floor'|'round'|'ceil'*/ dimRoundingMode]); external dynamic/*=T*/ conv2d /*<T extends Tensor<Rank.R3>|Tensor<Rank.R4>>*/( /*T this*/ Tensor<Rank.R4> filter, dynamic/*Tuple of <num,num>|num*/ strides, dynamic/*'valid'|'same'|num*/ pad, [String/*'NHWC'|'NCHW'*/ dataFormat, dynamic/*Tuple of <num,num>|num*/ dilations, String/*'floor'|'round'|'ceil'*/ dimRoundingMode]); external dynamic/*=T*/ conv2dTranspose /*<T extends Tensor<Rank.R3>|Tensor<Rank.R4>>*/( /*T this*/ Tensor<Rank.R4> filter, List<num>/*Tuple of <num,num,num,num>|Tuple of <num,num,num>*/ outputShape, dynamic/*Tuple of <num,num>|num*/ strides, dynamic/*'valid'|'same'|num*/ pad, [String/*'floor'|'round'|'ceil'*/ dimRoundingMode]); external dynamic/*=T*/ depthwiseConv2D /*<T extends Tensor<Rank.R3>|Tensor<Rank.R4>>*/( /*T this*/ Tensor<Rank.R4> filter, dynamic/*Tuple of <num,num>|num*/ strides, dynamic/*'valid'|'same'|num*/ pad, [String/*'NHWC'|'NCHW'*/ dataFormat, dynamic/*Tuple of <num,num>|num*/ dilations, String/*'floor'|'round'|'ceil'*/ dimRoundingMode]); external dynamic/*=T*/ avgPool /*<T extends Tensor<Rank.R3>|Tensor<Rank.R4>>*/( /*T this*/ dynamic/*Tuple of <num,num>|num*/ filterSize, dynamic/*Tuple of <num,num>|num*/ strides, dynamic/*'valid'|'same'|num*/ pad, [String/*'floor'|'round'|'ceil'*/ dimRoundingMode]); external dynamic/*=T*/ maxPool /*<T extends Tensor<Rank.R3>|Tensor<Rank.R4>>*/( /*T this*/ dynamic/*Tuple of <num,num>|num*/ filterSize, dynamic/*Tuple of <num,num>|num*/ strides, dynamic/*'valid'|'same'|num*/ pad, [String/*'floor'|'round'|'ceil'*/ dimRoundingMode]); external dynamic/*=T*/ localResponseNormalization /*<T extends Tensor<Rank.R3>|Tensor<Rank.R4>>*/( /*T this*/ [num radius, num bias, num alpha, num beta]); external Variable<R> variable([bool trainable, String name, keyof dtype]); }

 /*export declare type Scalar = Tensor<Rank.R0>;*/ 
 /*export declare type Tensor1D = Tensor<Rank.R1>;*/ 
 /*export declare type Tensor2D = Tensor<Rank.R2>;*/ 
 /*export declare type Tensor3D = Tensor<Rank.R3>;*/ 
 /*export declare type Tensor4D = Tensor<Rank.R4>;*/ 
 @JS() class Variable <R extends Rank, Rank > extends Tensor<R> { // @Ignore
 Variable .fakeConstructor$() : super.fakeConstructor$() ;
 external bool get trainable; external set trainable(bool v); external static get nextVarId; external static set nextVarId(v); external String get name; external set name(String v); external factory Variable(); external static Variable<dynamic/*=R*/> variable /*<R extends Rank>*/(Tensor<dynamic/*=R*/> initialValue, [bool trainable, String name, keyof dtype]); external void assign(Tensor<R> newValue); }

 @JS() external dynamic get variable; export show variable ;

